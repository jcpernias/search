---
title: "Bias and Size Effects of Price-Comparison Platforms: Theory and Experimental Evidence"
output:
  pdf_document: 
    number_sections: true
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = " ")
library(tidyverse)
library(broom)
library(knitr)
library(lazyeval)
```

# Data

The variables are stored in three files: one for treatment design variables, `./data/treatments.csv`; another for lotteries results, `./data/subjects.csv`; and, finally, one for prices, `./data/prices.csv`.

## Treatment design variables
```{r}
treat_db <- read_csv('./data/treatments.csv', col_types = "ilii") %>%
  mutate(phi = if_else(selective, 1, k/n))

kable(treat_db, digits = 3)
```

Variables:

- `treat_id`: the treatment id.
- `selective`: `TRUE` if the treatment's search engine is selective. 
- `n`: number of firms in each treatment's market.
- `k`: number of firms in the index, $k \leq n$.
- `phi`: the ex-ante probability of being included in the index for the fims that actually ended up being indexed. 

## Lotteries results
```{r}
subjects_db <- read_csv('./data/subjects.csv', col_types = "idddd")
glimpse(subjects_db)
```

Variables:

- `subject_id`: the subject id.
- `p1, p2, p3, p4`: subject's lottery choices in each of the four panels; a double between 0.0 and 1.0. 


## Prices 
```{r}
prices_db <- read_csv('./data/prices.csv', col_types = "iiiild")
glimpse(prices_db)
```

Variables:

- `treat_id`: treatment id.
- `market_id`: market id.
- `period`: time period.
- `subject_id`: subject id.
- `indexed`: `TRUE` if the price is included in the index.
- `price`: the price; a double between 0.0 and 1.0.

# Results

## Theoretical distributions

The equilibrium theoretical distribution is given by
\begin{equation*}
F(p; n, k, \phi, \lambda) = 
\begin{cases}
0 & 0 \leq p < l \\
1 - \left[
  \dfrac{1}{n \phi}
  \dfrac{\lambda}{1 - \lambda}
  \dfrac{1 - p}{p}
\right]^{1/(k-1)}
& l \leq p \leq 1 
\end{cases}
\end{equation*}
where 
\begin{equation*}
l = \frac{\lambda}{\lambda + (1 - \lambda) n \phi}
\end{equation*}

We use a closure to build the cdf for a given combination of parameters:

```{r}
Fsearch <- function(n, k, phi, lambda = 1 / 2) {
  const <- (lambda / (1 - lambda)) / (n * phi)
  low <- lambda / (lambda + (1 - lambda) * n * phi)
  pow <- 1 / (k - 1)
  function(p) {
    ans <- rep_along(p, 0)

    idx <- p >= 1.0
    if (any(idx)) {
      ans[idx] <- 1.0
    }

    idx <- p > low & p < 1.0
    if(any(idx)) {
      pi <- p[idx]
      ans[idx] <- 1 - (const * (1 - pi) / pi) ^ pow
    }

    ans
  }
}
```

As prices are non-negative random variables, we will compute their expectation as:
\begin{equation*}
  E(p) = \int_{0}^{\infty} 1 - F(p)\; dp
\end{equation*}
We will use the following functional operator to obtain the complement of a cdf:

```{r}
compl_cdf <- function(cdf) {
  function(x) {
    1 - cdf(x)
  }
}
```

Another useful result for non-negative random variables:
\begin{equation*}
  E(p^2) = 2 \int_{0}^{\infty} p \big(1 - F(p)\big)\; dp
\end{equation*}
We will compute the above formula with the help of the following functional operator:

```{r}
func_arg <- function(func) {
  function(x) {
    func(x) * x
  }
}
```

Finally, the cdf of the minimum of $n$ random variables, all of them with cdf $F(p)$, is given by:
\begin{equation*}
  G(p) = 1 - \big[ 1 - F(p) \big]^n
\end{equation*}
The next functional operator will be used:

```{r}
func_pow <- function(func, pow) {
  function(x) {
    func(x)^pow
  }
}
```

The following function computes the mean and standard deviation of average market prices, `pavg`, and minimum market prices, `pmin`:

```{r}
moments <- function(n, k, phi, treat_id, selective) {
  mean_sd <- function(ccdf, num = 1) {
    EX <- integrate(ccdf, lower = 0, upper = 1)
    EX2 <- integrate(func_arg(ccdf), lower = 0, upper = 1)
    VX <-  2 * EX2$value - EX$value^2
    list(mu = EX$value, sd = sqrt(VX) / sqrt(num))
  }
  
  ccdf <- compl_cdf(Fsearch(n = n, k = k, phi = phi))
  pavg_mom <- mean_sd(ccdf, if_else(selective, k, n))
  pmin_mom <- mean_sd(func_pow(ccdf, k))
  tibble(treat = treat_id, 
         pavg_mean = pavg_mom$mu, pavg_sd = pavg_mom$sd,
         pmin_mean = pmin_mom$mu, pmin_sd = pmin_mom$sd)  
}
```

Table with moments of the equilibrium price distributions for the 8 treatments:

```{r}
mom_db <- treat_db %>% pmap_df(moments)
kable(mom_db, digits = 3)
```


## Sample

The first 20 periods are dropped from the sample. Two new price variables:

- Available prices: all prices from that could be indexed, i.e., all prices in unselective coverage treatments and those from indexed vendors in selective coverage treatments; `pavail`. Average market prices are based on this variable.
- Indexed prices: only the prices of indexed vendors in every treatment; `pindex`. The minimum of these prices in each market is the price paid by shoppers. 



```{r}
smpl <- left_join(prices_db, treat_db, by = 'treat_id') %>% 
  filter(period > 20) %>%
  mutate(pavail = if_else(!selective | indexed, price, NA_real_),
         pindex = if_else(indexed, price, NA_real_))
```

Compute average market prices and average prices paid by shoppers. Also, create the `groups` variable. It will be used later to test for trends. 

```{r}
markets <- smpl %>% group_by(market_id) %>%
  summarise(treat = first(treat_id),
            period = first(period),
            pavg = mean(pavail, na.rm = TRUE),
            pmin = min(pindex, na.rm = TRUE)) %>%
  mutate(group = as.integer(floor((period  - 1) / 10) - 1))
```

Descriptive statistics reported on Table 1:

```{r}
dstats <- markets %>% group_by(treat) %>%
  summarise('Avg p: mean' = mean(pavg),
            'Avg p: sd' = sd(pavg),
            'Min p: mean' = mean(pmin),
            'MIn p: sd' = sd(pmin))

kable(dstats, digits = 3)
```



```{r}
mean_tests <- function(data, var, by_var, ...) {
  data %>% 
    mutate_(x = var) %>% 
    group_by_(by_var) %>%  
    do(tidy(t.test(.$x, ...))) %>%
    select_(by_var, "statistic", "p.value")
}
```

t-tests on means of average prices:

```{r}
mean_tests(left_join(markets, mom_db, by = "treat"), 
           var = ~pavg - pavg_mean,
           by_var = ~treat) %>%
  kable(digits = 3)
```

```{r}
mean_tests(left_join(markets, mom_db, by = "treat"), 
           var = ~pmin - pmin_mean,
           by_var = ~treat) %>%
  kable(digits = 3)
```


Descriptive statistics for observations from the 10 last periods:

```{r}
dstats <- filter(markets, group == 3) %>% 
  group_by(treat) %>%
  summarise('Avg p: mean' = mean(pavg),
            'Avg p: sd' = sd(pavg),
            'Min p: mean' = mean(pmin),
            'MIn p: sd' = sd(pmin))

kable(dstats, digits = 3)
```

```{r}
mean_tests(left_join(filter(markets, group == 3),
                     mom_db, by = "treat"), 
           var = ~pavg - pavg_mean,
           by_var = ~treat) %>%
  kable(digits = 3)
```

```{r}
mean_tests(left_join(filter(markets, group == 3),
                     mom_db, by = "treat"), 
           var = ~pmin - pmin_mean,
           by_var = ~treat) %>%
  kable(digits = 3)
```


## Trends

We use plots in order to find evidence on the presence of trends in the expected prices. 

```{r}
trend_plots <- function(var) {
  ggplot(data = markets, mapping = aes_(x = ~period, y = var)) +
    geom_point(size=0.4) +
    facet_wrap(ncol=2, ~ treat)  +
    geom_smooth(method = "lm", size = 0.6)
}
```


We also use Kruskal-Wallis tests to test the hypothesis that the mean of expected prices is the same across all periods. In order to do so, we divide the sample in three groups of 10 periods each. We perform two tests. One tests the null hypothesis that the three periods having the same mean. The other tests the null that the mean of the first periods is the same than the mean of the last periods. Finally, we test that the prices are associated with a trend. We use the Kendall correlation coefficient in order to allow for possible nonlinear association.  


```{r}
# Compute Kruskal-Wallis tests: 
# - data: data set 
# - by_var: a rhs formula indicating a variable; the data set is 
#           sliced according to this variable and a  test is performed
#           in each slice.
# - frml: a rhs formula; the variable being tested
# - filter_frml: a condition to filter the data set
kw_tests <- function(data, by_var, frml, filter_frml = NULL) {
  if (!is.null(filter_frml))
    data <- filter_(data, filter_frml)
  data %>% group_by_(by_var) %>% 
    do(tidy(kruskal.test(frml, data = .))) %>%
         select(-one_of(c("method", "parameter")))
}


corr_tests <- function(data, by_var, frml, method = "kendall") {
  inner <- function(data, frml, method) {
    f_env(frml) <- environment()
    cor.test(frml, method = method, data = data)
  }
  
  data %>% group_by_(by_var) %>% 
    do(tidy(inner(., frml, method))) %>%
    select(-one_of(c("method", "statistic", "alternative")))
}

trend_tests <- function(var, group, filter_frml) {
  kw_frml <- f_new(uq(group), uq(var))
  # Kruskal-Wallis using all periods
  kw1 <- kw_tests(markets, ~treat, kw_frml)
  
  # Kruskal-Wallis dropping the central periods:
  kw2 <- kw_tests(markets, ~treat, kw_frml, filter_frml)

  # Kendall correlation tests
  kend_frml <- f_interp(~uq(var) + period)
  kend <- corr_tests(markets, ~treat, kend_frml)
  
  # Bind the three tables; rename the columns.
  left_join(kw1, kw2, by = "treat") %>%
    rename(kw_all = statistic.x, pv_kw_all = p.value.x, 
           kw_drop = statistic.y, pv_kw_drop = p.value.y) %>%
    left_join(kend, by = "treat") %>%
    rename(kendall = estimate, pv_kendall = p.value)
}

```



### Average market prices

Plots:

```{r}
trend_plots(~pavg)
```


Collect all tests in one table:

```{r}
kable(trend_tests(~pavg,  ~group, ~ group != 2), digits = 3)
```

Conclusions:

- Apart from Treatment 1, there is little evidence on the presence of trends in the experimental data. 
- Although the tests indicate, at the 5% significance level, the presence of a trend in Treatment 1, the strength of this trend is small, as measured by the Kendall correlation coefficient.

### Minimum market prices


Plots:

```{r}
trend_plots(~pmin)
```




Collect all tests in one table:

```{r}
kable(trend_tests(~pmin,  ~group, ~ group != 2), digits = 3)

```


## Tests

```{r}
treat_test <- function(var, group_var, g1, g2, data, ...,
                       test_func = t.test) {
  x <- data[[var]]
  g <- data[[group_var]]
  test_func(x[g == g1], x[g == g2], ...)
} 

treat_map <- function(var, g1, g2, H1, ...) {
  test <- treat_test(var, "treat", g1, g2, alternative = H1, ...)
  c(g1 = g1, g2 = g2, H1 = H1, test[c("statistic", "p.value")])
}

pavg_map <- function(g1, g2, H1, ...) {
  treat_map("pavg", g1, g2, H1, ...)
}

pmin_map <- function(g1, g2, H1, ...) {
  treat_map("pmin", g1, g2, H1, ...)
}

pavg_hyp <- list(g1 = c(1, 5, 7, 7, 2, 2, 6, 8, 8, 3, 8, 6, 8, 3),
                 g2 = c(4, 4, 4, 5, 1, 7, 4, 4, 6, 1, 3, 5, 7, 2),
                 H1 = c(rep("less", 5), "two.sided", rep("less", 8)))

pmin_hyp <- list(g1 = c(4, 4, 4, 5, 1, 2, 6, 8, 8, 3, 8, 6, 8, 3),
                 g2 = c(1, 5, 7, 7, 2, 7, 4, 4, 6, 1, 3, 5, 7, 2),
                 H1 = c(rep("less", 5), "two.sided", rep("less", 8)))

```

```{r}

pv_to_stars <- function(pv) {
  ans <- rep_along(pv, "  ")
  idx <- pv <= 0.01
  ans[idx] <- "**"

  idx <- pv <= 0.05 & pv > 0.01
  ans[idx] <- "* "
  
  ans
}

fmt_tests <- function(g1, g2, H1, statistic, p.value, prefix = "eps_") {
  cvt <- c("less" = " < ", "greater" = " > ", "two.sided" = " != ")
  H1str <- paste(prefix, g1, cvt[H1], prefix, g2, sep = "")
  tibble(H1 = H1str, stat = statistic, pv = pv_to_stars(p.value))
}

pmap_df(pavg_hyp, pavg_map, data = markets, var.equal = TRUE) %>%
  pmap_df(fmt_tests) %>%
  kable(digits = 2, col.names = c("H1", "t", ""))
```

```{r}
pmap_df(pmin_hyp, pmin_map, data = markets, var.equal = TRUE) %>%
  pmap_df(fmt_tests, prefix = "mu_") %>%
  kable(digits = 2, col.names = c("H1", "t", ""))
```

```{r}
pmap_df(pavg_hyp, pavg_map, data = markets, exact = FALSE, 
        test_func = wilcox.test) %>%
  pmap_df(fmt_tests) %>%
  kable(digits = 3, col.names = c("H1", "W", ""))
```

```{r}
pmap_df(pmin_hyp, pmin_map, data = markets, exact = FALSE, 
        test_func = wilcox.test) %>%
  pmap_df(fmt_tests, prefix = "mu_") %>%
  kable(digits = 2, col.names = c("H1", "W", ""))
```

```{r}
markets3 <- filter(markets, group == 3)

pmap_df(pavg_hyp, pavg_map, data = markets3, exact = FALSE, 
        test_func = wilcox.test) %>%
  pmap_df(fmt_tests) %>%
  kable(digits = 2, col.names = c("H1", "W (last)", ""))
```

```{r}
pmap_df(pmin_hyp, pmin_map, data = markets3, exact = FALSE,
        test_func = wilcox.test) %>%
  pmap_df(fmt_tests, prefix = "mu_") %>%
  kable(digits = 2, col.names = c("H1", "W (last)", ""))
```

