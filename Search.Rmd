---
title: "Bias and Size Effects of Price-Comparison Platforms: Theory and Experimental Evidence"
output:
  pdf_document: 
    number_sections: true
    df_print: kable
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = " ")
library(tidyverse)
library(broom)
library(knitr)
library(lazyeval)
```

# Data

The variables are stored in three files: one for treatment design variables, `./data/treatments.csv`; another for lotteries results, `./data/subjects.csv`; and, finally, one for prices, `./data/prices.csv`.

## Treatment design variables
```{r}
treat_db <- read_csv('./data/treatments.csv', col_types = "ilii")
kable(treat_db, align = "cccc")
```

Variables:

- `treat_id`: the treatment id; an integer.
- `selective`: true if the treatment's search engine is biased; a logical. 
- `n`: number of firms in the market; an integer.
- `k`: number of firms in the index, $k \leq n$; an integer.

## Lotteries results
```{r}
subjects_db <- read_csv('./data/subjects.csv', col_types = "idddd")
glimpse(subjects_db)
```

Variables:

- `subject_id`: the subject id; an integer.
- `p1, p2, p3, p4`: subject's lottery choices in each of the four panels; a double between 0.0 an 1.0. 


## Prices 
```{r}
prices_db <- read_csv('./data/prices.csv', col_types = "iiiild")
glimpse(prices_db)
```

Variables:

- `treat_id`: treatment id; an integer.
- `market_id`: market id; an integer.
- `period`: time period; an integer.
- `subject_id`: subject id; an integer.
- `indexed`: true if the price is included in the index; a logical.
- `price`: the price; a double between 0.0 and 1.0.

# Results

## Sample

The first 20 periods are dropped from the sample. Two new price variables:

- Available prices: all prices from that could be indexed, i.e., all prices in unselective coverage treatments and those from indexed vendors in selective coverage treatments; `pavail`. Average market prices are based on this variable.
- Indexed prices: only the prices of indexed vendors in every treatment; `pindex`. The minimum of these prices in each market is the price paid by shoppers. 



```{r}
smpl <- left_join(prices_db, treat_db, by = 'treat_id') %>% 
  filter(period > 20) %>%
  mutate(pavail = if_else(!selective | indexed, price, NA_real_),
         pindex = if_else(indexed, price, NA_real_))
```

Compute average market prices and average prices paid by shoppers. Also, create the `groups` variable. It will be used later to test for trends. 

```{r}
markets <- smpl %>% group_by(market_id) %>%
  summarise(treat = first(treat_id),
            period = first(period),
            pavg = mean(pavail, na.rm = TRUE),
            pmin = min(pindex, na.rm = TRUE)) %>%
  mutate(group = as.integer(floor((period  - 1) / 10) - 1))
```

Descriptive statistics reported on Table 1:

```{r}
dstats <- markets %>% group_by(treat) %>%
  summarise('Avg p: mean' = mean(pavg),
            'Avg p: sd' = sd(pavg),
            'Min p: mean' = mean(pmin),
            'MIn p: sd' = sd(pmin))

kable(dstats, digits = 3)
```


## Trends

We use plots in order to find evidence on the presence of trends in the expected prices. We also use Kruskal-Wallis tests to test the hypothesis that the mean of expected prices is the same across all periods. In order to do so, we divide the sample in three groups of 10 periods each. We perform two tests. One tests the null hypothesis of the three periods having the same mean. The other tests the null that the mean of the first periods is the same than the mean of the last periods. Finally, we test that the prices are associated with a trend. We use the Kendall correlation coefficient in order to allow for possible nonlinear association.  


```{r}
kw_tests <- function(data, by_var, frml, filter_frml = NULL) {
  if (!is.null(filter_frml))
    data <- filter_(data, filter_frml)
  data %>% group_by_(by_var) %>% 
    do(tidy(kruskal.test(frml, data = .))) %>%
         select(-one_of(c("method", "parameter")))
}


corr_tests <- function(data, by_var, frml, method = "kendall") {
  inner <- function(data, frml, method) {
    f_env(frml) <- environment()
    cor.test(frml, method = method, data = data)
  }
  
  data %>% group_by_(by_var) %>% 
    do(tidy(inner(., frml, method))) %>%
    select(-one_of(c("method", "statistic", "alternative")))
}

trend_tests <- function(var, group, filter_frml) {
  kw_frml <- f_new(uq(group), uq(var))
  # Kruskal-Wallis using all periods
  kw1 <- kw_tests(markets, ~treat, kw_frml)
  
  # Kruskal-Wallis dropping the central periods:
  kw2 <- kw_tests(markets, ~treat, kw_frml, filter_frml)

  # Kendall correlation tests
  kend_frml <- f_interp(~uq(var) + period)
  kend <- corr_tests(markets, ~treat, kend_frml)
  
  left_join(kw1, kw2, by = "treat") %>%
    rename(kw_all = statistic.x, pv_kw_all = p.value.x, 
           kw_drop = statistic.y, pv_kw_drop = p.value.y) %>%
    left_join(kend, by = "treat") %>%
    rename(kendall = estimate, pv_kendall = p.value)
}

```



### Average market prices

Plots:

```{r}
  ggplot(data = markets, mapping = aes(x = period, y = pavg)) +
    geom_point(size=0.4) +
    facet_wrap(ncol=2, ~ treat)  +
    geom_smooth(method = "lm", size = 0.4) 
```



Collect all tests in one table:

```{r}
kable(trend_tests(~pavg,  ~group, ~ group != 2), digits = 3)
```

Conclusions:

- Apart from Treatment 1, there is little evidence on the presence of trends in the experimental data. 
- Although the tests indicate, at the 5% significance level, the presence of a trend in Treatment 1, the strength of this trend is small, as measured by the Kendall correlation coefficient.

### Minimum market prices


Plots:

```{r}
ggplot(data = markets, mapping = aes(x = period, y = pmin)) +
  geom_point(size=0.4) +
  facet_wrap(ncol=2, ~ treat)  +
  geom_smooth(method = "lm", size = 0.4) 
```




Collect all tests in one table:

```{r}
kable(trend_tests(~pmin,  ~group, ~ group != 2), digits = 3)

```


## Tests

```{r}
treat_test <- function(var, group_var, g1, g2, data, ...,
                       test_func = t.test) {
  x <- data[[var]]
  g <- data[[group_var]]
  test_func(x[g == g1], x[g == g2], ...)
} 

treat_map <- function(var, g1, g2, H1, ...) {
  test <- treat_test(var, "treat", g1, g2, alternative = H1, ...)
  c(g1 = g1, g2 = g2, H1 = H1, test[c("statistic", "p.value")])
}

pavg_map <- function(g1, g2, H1, ...) {
  treat_map("pavg", g1, g2, H1, ...)
}

pmin_map <- function(g1, g2, H1, ...) {
  treat_map("pmin", g1, g2, H1, ...)
}

pavg_hyp <- list(g1 = c(1, 5, 7, 7, 2, 2, 6, 8, 8, 3, 8, 6, 8, 3),
                 g2 = c(4, 4, 4, 5, 1, 7, 4, 4, 6, 1, 3, 5, 7, 2),
                 H1 = c(rep("less", 5), "two.sided", rep("less", 8)))

pmin_hyp <- list(g1 = c(4, 4, 4, 5, 1, 2, 6, 8, 8, 3, 8, 6, 8, 3),
                 g2 = c(1, 5, 7, 7, 2, 7, 4, 4, 6, 1, 3, 5, 7, 2),
                 H1 = c(rep("less", 5), "two.sided", rep("less", 8)))


pmap_df(pavg_hyp, pavg_map, data = markets, var.equal = TRUE)

pmap_df(pmin_hyp, pmin_map, data = markets, var.equal = TRUE)

pmap_df(pavg_hyp, pavg_map, data = markets, exact = FALSE, 
        test_func = wilcox.test)

pmap_df(pmin_hyp, pmin_map, data = markets, exact = FALSE, 
        test_func = wilcox.test)

markets3 <- filter(markets, group == 3)

pmap_df(pavg_hyp, pavg_map, data = markets3, exact = FALSE, 
        test_func = wilcox.test)

pmap_df(pmin_hyp, pmin_map, data = markets3, exact = FALSE,
        test_func = wilcox.test)



```

